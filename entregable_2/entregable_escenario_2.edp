// difusion transporte REACCION O DECAIMIENTO EN EL TIEMPO con implementacion derivada TOTAL, cond conctorno de conveccion a la salida
// CON ADAPTACION DE MALLA

//Definimos el dominio de estudio, creamos la malla y la dibujamos
//----------------------------------------------------------------
real L = 2.0;
real H = 0.5;

// Pared inferior
border a(t=0, L) {
    x = t;
    y = 0;
    label = 1;
};

// Salida (derecha)
border b(t=0, H) {
    x = L;
    y = t;
    label = 5;
};

// Techo ondulado
border c(t=L, 0) {
    x = t;
    y = 0.375 + 0.125 * (sin(pi * (x + 0.5)));
    label = 3;
};

// Entrada (izquierda)
border d(t=H, 0) {
    x = 0;
    y = t;
    label = 4;
};

int n = 80;
mesh malla = buildmesh(a(n) + b(n) + c(n) + d(n));
plot(malla, wait=1);

//Definimos el problema que queremos resolver
//-------------------------------------------
fespace Vh(malla,P2);
Vh u,v,kx,ky,u1,u2,uoldt,uu; // u es temperatura en grados Celsius  , añadido uoldt que es la solucion u en la iteracion anterior en bucle abajo

//Conductividad térmica constante
kx=0.02624;  
ky=0.02624;

real densidad,cp;
densidad=1.1769;
cp=1.0073;
real A;
A= densidad*cp;

u1=48*y*(0.5 - y); // componente horizontal, obtuvimos para que en el centro la v max fuera 3 m/s
u2=0; // u2 es cero, la componente vertical del vector velocidad es cero 

real dt=0.01;
real r=0.001;

real AA = 100000000.;
real h=1000.;
real aa = 1.0;
real bb = 0.125;

uoldt = AA*exp(-h*((x-aa)^2 +(y-bb)^2));

real alpha=1/dt;

problem transporte(u, v)
  = int2d(malla)( A*u*v/dt )
  - int2d(malla)( A*alpha*convect([u1, u2], -dt, uoldt)*v ) // derivada total
  + int2d(malla)( kx*dx(u)*dx(v) + ky*dy(u)*dy(v) )
  + int2d(malla)( r*u*v )
  + on(4, u=0);   // concentración cero en la entrada, salida libre
int iter = 0;
real tfinal = 200.;  // algo suficientemente grande; luego acabamos antes si u cae
real tlim = -1;      // tiempo en el que se “extingue” el contaminante
real tol = 1e-6;

for (real t = 0; t < tfinal; t += dt) {
    iter++;

    transporte;   // resuelve para u en el instante t+dt
    uoldt = u;

    // Máxima concentración en el dominio
    real umax = u[].max;

    cout << "t = " << t+dt << ", umax = " << umax << endl;
    plot(u, cmm = "t = " + (t+dt), value = 1);

    // Adaptamos malla en cada iteración
    malla = adaptmesh(malla, u,
        err = 0.001,
        hmax = 0.1,
        hmin = 0.001,
        cutoff = 1e-6,
        ratio = 1.6,
        nbvx = 20000,
        splitpbedge = 2,
        power = 1,
        abserror = true,
        nomeshgeneration = false,
        anisomax = 1
    );

    if (umax < tol && tlim < 0) {
        tlim = t + dt;
        cout << "Concentracion < " << tol << " en todo el dominio en t = " << tlim << endl;
        break;  // ya no hay contaminación apreciable
    }
}

if (tlim < 0)
    cout << "No se ha alcanzado el umbral de " << tol << " antes de t = " << tfinal << endl;


