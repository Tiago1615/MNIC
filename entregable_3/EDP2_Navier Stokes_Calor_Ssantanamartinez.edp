// difusion transporte con implementacion derivada parcial, cond conctorno de conveccion a la salida

// ======================================================
// 1. Dominio y malla
// OJO LABELS: 1 entrada, 3 salida, 4 superior, 2 inferior
// ======================================================
border a(t=0,2) {
    x = t;
    y = -(0.375 + 0.125*sin(pi*(t+0.5))); // borde inferior ondulado
    label = 2;
};

border b(t=-0.5,0.5) {
    x = 2;
    y = t;                                // borde de salida
    label = 3;
}; 

border c(t=2,0) {
    x = t;
    y = 0.375 + 0.125*sin(pi*(t+0.5));    // borde superior ondulado
    label = 4;
};

border d(t=0.5,-0.5) {
    x = 0;
    y = t;                                // borde de entrada
    label = 1;
};

int n = 80;
mesh malla = buildmesh(a(n)+b(n)+c(n)+d(n));
plot(malla, wait=1, cmm="Malla inicial");

// ======================================================
// 2. Espacios de funciones SEPARADOS
//    V1 (P1) -> velocidades y presion
//    Vh (P2) -> temperatura
// ======================================================
fespace V1(malla,P1);   // Navier–Stokes
fespace Vh(malla,P2);   // calor

V1 u1,u2,w,p,q;         // velocidad y presion
Vh u,v,uoldt;           // temperatura

//Conductividad térmica constante (como escalares)
real kx = 0.02624;  
real ky = 0.02624;

real hc = 10.;   //Coeficiente de convección   W/m2
real uf = 25.;   // temperatura del aire exterior a la salida

real densidad = 1.1769;
real cp       = 1.0073;
real A        = densidad*cp;

// ======================================================
// 3. Navier Stokes estacionario -> u1, u2
// ======================================================
real nu   = 0.000016;              // viscosidad cinematica
real area = int2d(malla)(1.);      // area del dominio

u1 = 0;                            // inicializamos velocidades
u2 = 0;
p  = 0;

// Paso de tiempo segun numero de Courant 0.9
real umax = 3.0;            // vmax conocida en la entrada
real hmin = malla.hmin;
real dt   = 0.9 * hmin / umax;
cout << "Courant 0.9: hmin = " << hmin << ", dt = " << dt << endl;

int  iterNS = 0;
real tNS, tmaxNS = 1.;                // paso de tiempo interno NS
real alphaNS = 1./dt;

for (tNS = 0; tNS < tmaxNS; tNS += dt)
{
    iterNS++;

    V1 u1old = u1, u2old = u2, pold = p;
    V1 f = convect([u1,u2], -dt, u1old);
    V1 g = convect([u1,u2], -dt, u2old);

    // ---- Componente u1 ----
    solve pb4u(u1,w,init=n,solver=LU)
      = int2d(malla)( u1*w/dt + nu*(dx(u1)*dx(w) + dy(u1)*dy(w)) )
      - int2d(malla)( (f/dt - dx(p))*w )
      + on(1, u1 = umax*(1 - (y/0.5)^2)) // Entrada: perfil parabolico vmax=3 en y=0, 0 en y=±0.5
      + on(2,4, u1 = 0)
      + on(3, u1 = f);

    // ---- Componente u2 ----
    solve pb4v(u2,w,init=n,solver=LU)
      = int2d(malla)( u2*w/dt + nu*(dx(u2)*dx(w) + dy(u2)*dy(w)) )
      - int2d(malla)( (g/dt - dy(p))*w )
      + on(1,4,2, u2 = 0)
      + on(3, u2 = g);

    // ---- Presión ----
    real meandiv = int2d(malla)(dx(u1)+dy(u2))/area;

    solve pb4p(q,w,init=n,solver=LU)
      = int2d(malla)( dx(q)*dx(w) + dy(q)*dy(w) )
      - int2d(malla)( (dx(u1)+dy(u2)-meandiv)*w/dt )
      + on(3, q = 0);

    real meanpq = int2d(malla)(pold - q)/area;
    p  = pold - q - meanpq;
    u1 = u1 + dx(q)*dt;
    u2 = u2 + dy(q)*dt;

    if ( !(iterNS % 20) )
        plot([u1,u2], cmm="Navier-Stokes t="+tNS, value=1);
}

plot([u1,u2], cmm="Campo de velocidad estacionario", value=1, wait=1);

// ======================================================
// 4. Problema de calor (difusion + transporte) en Vh
// ======================================================

real alpha = 1./dt;

problem calor(u,v) = 
    int2d (malla) (A*u*v/dt)
  - int2d(malla) (A*alpha*convect([u1,u2],-dt,uoldt)*v) // derivada total
  + int2d(malla)(kx*dx(u)*dx(v)+ky*dy(u)*dy(v))
  + int1d(malla,3) (hc*u*v) - int1d(malla,3) (hc*uf*v)
  + on(1,u=15);  // aire entra a 15 grados

plot([u1,u2], cmm="Campo de velocidad usado en calor", value=1, wait=1);

// ======================================================
// 5. Bucle temporal para la temperatura
// ======================================================
int    iter = 0;
real   tfinal = 3;

for (real t=0; t < tfinal; t += dt)
{
    iter++;
    calor;            // resuelve u en el nuevo paso
    uoldt = u;        // actualiza para la derivada total

    plot(u, cmm="tiempo ="+t, value=1, WindowIndex=0);

    if (iter <= 2) {
        malla = adaptmesh(
            malla,
            u,
            err=0.01,
            hmax=0.1,
            hmin=0.001,
            cutoff=1e-6,
            ratio=1.6,
            nbvx=40000,
            splitpbedge=2,
            power=1,
            abserror=true,
            nomeshgeneration=false,
            anisomax=1
        );
        plot(malla, cmm="Malla adaptada, tiempo ="+t, WindowIndex=1);
    }
}
