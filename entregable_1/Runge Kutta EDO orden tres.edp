/*
   ECUACIÓN DE TERCER ORDEN
   t^3 y''' - t^2 y'' + 3t y' - 4y = 5t^3 ln(t) + 9t^3
   y(1)=0, y'(1)=1, y''(1)=3, h=0.1
*/

// Definición del paso y rango de integración
real X, XF, XI, N, h;
XI = 1;
XF = 2;
N=10;
h = (XF - XI) / N;

// Salida de los parámetros iniciales
cout << " XI = " << XI << endl;
cout << " XF = " << XF << endl;
cout << " N = " << N << endl;
cout << " h = " <<h << endl << endl;

// Sistema de ecuaciones de primer orden
func real f1(real X, real Y1, real Y2, real Y3) {
      return (Y2);
}

func real f2(real X, real Y1, real Y2, real Y3) {
      return (Y3);
}

func real f3(real X, real Y1, real Y2, real Y3) {
      return ( (pow(X, 2) * Y3 - 3 * X * Y2 + 4 * Y1 + 5 * pow(X, 3) * log(X) + 9 * pow(X, 3)) / pow(X, 3) );
}

// Solución real para comparación
func real realSolution(real X){
      return ( -pow(X, 2) + X * cos(log(X)) + X * sin(log(X)) + pow(X, 3) * log(X) );
}

// Variables para los coeficientes de Runge-Kutta
real k11, k21, k31, k12, k22, k32, k13, k23, k33, k14, k24, k34;
real Z1, Z2, Z3;

// Variables para la solución y el error
real solution;
real error;

// Inicialización de las condiciones iniciales (Y1 = y, Y2 = y', Y3 = y'')
real Y1 = 0;        // y(1) = 0
real Y2 = 1;        // y'(1) = 1
real Y3 = 3;        // y''(1) = 3
X=XI;               // Inicio del intervalo

// Salida de las condiciones iniciales
cout << " y(1) = " << Y1 << endl;
cout << " y'(1) = " << Y2 << endl;
cout << " y''(1) = " << Y3 << endl << endl;

// Escritura de resultados con 6 decimales y formato fijo (no científico)
ofstream results ("resultados/Runge Kutta EDO orden tres.txt");
results.precision(6);
results.fixed;

// Salida por pantalla con 6 decimales y formato fijo (no científico)
cout.precision(6);
cout.fixed;

// Encabezados de las tablas de resultados
cout << " X " << "                 Y1 " << "                 Y2 " << "                 Y3" << "               Solucion real" << "       Error (|Y1 - Yreal|)" << endl;
cout << " x = " << X << "       y1 = " << Y1 << "       y2 = " << Y2 << "       y3 = " << Y3 << "    Yreal = " << realSolution(X) << "    Valor = " << abs(Y1 - realSolution(X)) << endl;

// Guardado de la primera fila de resultados
results << "  " << X << "  " << Y1 << "  " << Y2 << "  " << Y3 << "  " << realSolution(X) << "  " << abs(Y1 - realSolution(X)) << "\n";

// ============================================================
//               MÉTODO DE RUNGE-KUTTA DE 4º ORDEN
// ============================================================

while(X<=XF) {    

      // Primera pendiente: evaluación en el punto inicial
      k11 = f1(X, Y1, Y2, Y3);
      k21 = f2(X, Y1, Y2, Y3);
      k31 = f3(X, Y1, Y2, Y3);

      // Segunda pendiente: evaluación en el punto medio (X + h/2)
      X = X + 0.5 * h;
      Z1 = Y1 + 0.5 * h * k11;
      Z2 = Y2 + 0.5 * h * k21;
      Z3 = Y3 + 0.5 * h * k31;

      // Se utilizan los valores de k11, k21, k31 para avanzar medio paso
      k12 = f1(X, Z1, Z2, Z3);
      k22 = f2(X, Z1, Z2, Z3);
      k32 = f3(X, Z1, Z2, Z3);

      // Tercera pendiente (nueva evaluación en el punto medio usando k12, k22, k32)
      Z1 = Y1 + 0.5 * h * k12;
      Z2 = Y2 + 0.5 * h * k22;
      Z3 = Y3 + 0.5 * h * k32;

      // Se avanza otra media longitud de paso (h/2)
      k13 = f1(X, Z1, Z2, Z3);
      k23 = f2(X, Z1, Z2, Z3);
      k33 = f3(X, Z1, Z2, Z3);

      // Cuarta pendiente: evaluación en el final del intervalo
      X = X + 0.5 * h;
      Z1 = Y1 + h * k13;
      Z2 = Y2 + h * k23;
      Z3 = Y3 + h * k33;

      // Se utilizan los valores de k13, k23, k33 para avanzar un paso completo
      k14 = f1(X, Z1, Z2, Z3);
      k24 = f2(X, Z1, Z2, Z3);
      k34 = f3(X, Z1, Z2, Z3);

      // Cálculo de la nueva solución mediante la fórmula de Runge-Kutta de cuarto orden
      Y1 = Y1 + h * (k11 + 2*k12 + 2*k13 + k14) / 6;
      Y2 = Y2 + h * (k21 + 2*k22 + 2*k23 + k24) / 6;
      Y3 = Y3 + h * (k31 + 2*k32 + 2*k33 + k34) / 6;

      // Salida de resultados por pantalla y archivo
      cout << " x = " << X << "       y1 = " << Y1 << "       y2 = " << Y2 << "       y3 = " << Y3 << "    Yreal = " << realSolution(X) << "    Valor = " << abs(Y1 - realSolution(X)) << endl;
      results << "  " << X << "  " << Y1 << "  " << Y2 << "  " << Y3 << "  " << realSolution(X) << "  " << abs(Y1 - realSolution(X)) << "\n";
}

cout << "\n============================\n";
cout << "Fin de ejecucion" << endl;
cout << "============================\n\n";
