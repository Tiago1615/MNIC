% Definir las matrices
Pa = [1 0; 0.2 0.8];
Pb = [1 0; 0 1];
Pc = [0.7 0.3; 0.4 0.6];

Pd = [0.9 0 0.1; 0.6 0.2 0.2; 0 0.6 0.4];
Pe = [0.8 0 0.2; 0 1 0; 0.9 0 0.1];
Pf = [0.25 0.05 0.7; 0.5 0.3 0.2; 0 0 1];

Pg = [0.8 0.2 0; 0.2 0.4 0.4; 0 0.3 0.7];

Ph = [0.4 0 0.4 0.2; 0.1 0.8 0 0.1; 0 0 1 0; 0.2 0 0.7 0.1];

Pi = [0.8 0.2 0 0; 0.3 0.7 0 0; 0 0 0.9 0.1; 0 0 0.4 0.6];

Pj = [0.5 0.1 0.3 0.1; 1 0 0 0; 0.2 0.1 0.7 0; 0 0 1 0];

Pk = [0.2 0.3 0.4 0.1; 0 1 0 0; 0.2 0.3 0.4 0.1; 0.1 0.4 0.2 0.3];

Pl = [0.9 0 0.1 0; 0.1 0.6 0.1 0.2; 0.3 0 0.7 0; 0 0 0 1];

% Comprobar posibles matrices absorbentes (Aquellas que tengan un 1 en la
% diagonal principal, son candidatas de ser absorbentes)

names = {'Pa', 'Pb', 'Pc', 'Pd', 'Pe', 'Pf', 'Pg', 'Ph', 'Pi', 'Pj', 'Pk', 'Pl'};
matrices = {Pa, Pb, Pc, Pd, Pe, Pf, Pg, Ph, Pi, Pj, Pk, Pl};

fprintf('\n--- Análisis de Candidatas a Absorbentes ---\n');

for i = 1:length(matrices)
    if any(diag(matrices{i}) == 1)
        fprintf('%s es una matriz candidata de ser absorbente.\n', names{i});
    end
end

% Las matrices que realmente son absorbentes son Pa, Pb, Pf, Ph y Pk. Aquí
% no se va a detellar el porqué, los motivos se explican en el informe.

true_absorbing_names = {'Pa', 'Pb', 'Pf', 'Ph', 'Pk'};
true_absorbing = {Pa, Pb, Pf, Ph, Pk};

% Calcular y mostrar la matriz fundamental para cada matriz absorbente

fprintf('\n--- Matriz Fundamental (F = (I - Q)^-1) para cada matriz absorbente ---\n');

for j = 1:length(true_absorbing)
    [F, Q] = calculate_fundamental_matrix(true_absorbing{j}); 
    
    fprintf('\n--- Resultados para %s ---\n', true_absorbing_names{j});
    
    fprintf('Matriz Q (Estados no absorbentes):\n');
    if isempty(Q), disp('[]'); else, disp(Q); end
    
    fprintf('Matriz Fundamental F:\n');
    if isempty(F), disp('[]'); else, disp(F); end
end

% Comprobar matrices regulares. Una matriz de transición P, es regular si
% si los términos de P^k (donde k es una potencia positiva) son
% estrictamente positivos.

remaining_matrices_names = {'Pc', 'Pd', 'Pe', 'Pg', 'Pi', 'Pj', 'Pl'};
remaining_matrices = {Pc, Pd, Pe, Pg, Pi, Pj, Pl};

fprintf('\n--- Comprobación de Matrices Regulares ---\n');

for z = 1:length(remaining_matrices)
    fprintf('\n--- Resultados para %s ---\n', remaining_matrices_names{z});
    is_regular_matrix(remaining_matrices{z});
end

% Las matrices han sido clasificadas

fprintf('\n--- Análisis completado ---\n');

regular_matrices_names = {'Pc', 'Pd', 'Pg', 'Pj'};
undefined_matrices_names = {'Pe', 'Pi', 'Pl'};

fprintf('\n--- Matrices absorbentes: ---\n');
for idx = 1:length(true_absorbing_names)
    fprintf('%s\n', true_absorbing_names{idx});
end

fprintf('\n--- Matrices regulares: ---\n');
for idx = 1:length(regular_matrices_names)
    fprintf('%s\n', regular_matrices_names{idx});
end

fprintf('\n--- Matrices no absorbentes y no regulares: ---\n');
for idx = 1:length(undefined_matrices_names)
    fprintf('%s\n', undefined_matrices_names{idx});
end

% Métodos auxiliares
function [F, Q] = calculate_fundamental_matrix(M)
    abs_states = [];
    n = size(M,1);
    for i = 1:n
        if M(i,i) == 1 && all(M(i,[1:i-1,i+1:n]) == 0)
        abs_states(end+1) = i;
        end
    end
    trans_states = setdiff(1:n, abs_states);

    if isempty(trans_states)
        Q = [];
        F = [];
    else
        Q = M(trans_states, trans_states);
        F = inv(eye(size(Q)) - Q);
    end
end

function [] = is_regular_matrix(M)
    regular = false;
    for k = 1:50
        if all(M(:) > 0)
            fprintf("Regular: si, k = %d\n", k);
            regular = true;
            break;
        end
        M = M*M;
    end

    if regular == false
        fprintf("La matriz no es regular para k, en el rango: 1 <= k <= %d\n", k);
    end
end

function pi = stationary_vector(P)
    n = size(P,1);

    % Sistema (P^T - I) * pi = 0
    A = [P' - eye(n); ones(1,n)];
    b = [zeros(n,1); 1];

    % Resolver sistema
    pi = A \ b;

    % Devolver como fila
    pi = pi.';
end
